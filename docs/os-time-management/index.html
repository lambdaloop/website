<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- 2022-09-25 Sun 22:21 -->
<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Time management in human and computer systems</title>
<meta content="Org mode" name="generator"/>
<meta content="lambdaloop" name="author"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="/css/code-theme.css" rel="stylesheet"/>
<link href="/css/style.css" rel="stylesheet"/>
<script src="/js/footnotes.js"></script>
<link href="https://fonts.googleapis.com/css?family=Source Sans" rel="stylesheet"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div class="status" id="preamble">
<a href="/" id="logo" title="Home">
<img class="logoimg" src="/images/logo_sm.png"/>
    lambdaloop
</a>
<hr/>
</div>
<div id="content">
<h1 class="title">Time management in human and computer systems</h1>
<div id="text-table-of-contents">
<ul>
<li><a href="#Parallels-between-human-and-OS-scheduling">1. Parallels between human and OS scheduling</a>
<ul>
<li><a href="#context-switching:-cognitive-vs-procedural">1.1. Context switching: cognitive vs procedural</a></li>
<li><a href="#time-to-completion:-often-unknown">1.2. Time to completion: often unknown</a></li>
<li><a href="#turnaround-time-vs-response-time:-choose-one">1.3. Turnaround time vs response time: choose one</a></li>
<li><a href="#Input/output:-blocks-tasks">1.4. Input/output: blocks tasks</a></li>
</ul>
</li>
<li><a href="#Modern-operating-system-schedulers">2. Modern operating system schedulers</a>
<ul>
<li><a href="#Multi-level-feedback-queue">2.1. Multi-level feedback queue</a></li>
<li><a href="#Fair-share-scheduler">2.2. Fair-share scheduler</a></li>
</ul>
</li>
<li><a href="#Scheduling-for-humans">3. Scheduling for humans</a></li>
</ul>
</div>
<p>
If you’re like me, you have a long todo list and a nagging sense that perhaps, you may not be doing your tasks in the <i>right</i> order. But how can you measure whether an order is better or worse, and how can you find the best one?
</p>
<p>
I first got answers to these questions when reading <a href="https://www.goodreads.com/book/show/25666050-algorithms-to-live-by">Algorithms to Live By</a>, in the chapter on the parallels between scheduling tasks in operating systems and in life <sup><a class="footref" href="#fn.1" id="fnr.1">1</a></sup>.
When reading about scheduling in actual operating systems, I found that the scheduling algorithms actually used account for more cases and are closer<sup><a class="footref" href="#fn.2" id="fnr.2">2</a></sup> to the real constraints of human task scheduling. They’re described in more detail here, along with the parallels I saw.
</p>
<div class="outline-2" id="outline-container-orgf997bed">
<h2 id="Parallels-between-human-and-OS-scheduling"><span class="section-number-2">1</span> Parallels between human and OS scheduling</h2>
<div class="outline-text-2" id="text-Parallels-between-human-and-OS-scheduling">
<p>
The more that I read about scheduling in operating systems, the more the parallels with human time management become clear. In fact, a lot of the discussion within OS scheduling is rather lucid, and sheds light in the tradeoffs of human time management.
</p>
</div>
<div class="outline-3" id="outline-container-org2dc6e94">
<h3 id="context-switching:-cognitive-vs-procedural"><span class="section-number-3">1.1</span> Context switching: cognitive vs procedural</h3>
<div class="outline-text-3" id="text-context-switching:-cognitive-vs-procedural">
<p>
Looking at OS context switching, we see that there are actually two different costs to context switches, which I distinguish as “procedural” and “cognitive”. <sup><a class="footref" href="#fn.3" id="fnr.3">3</a></sup> When switching tasks in a CPU, the biggest task is just switching out the values of the registers. This would be a “procedural” cost. However, as a CPU executes, it builds up state in various caches, which must be refilled again when switching tasks. This cost, much harder to quantify, would be a “cognitive” cost.
</p>
<p>
For humans, a “procedural” cost of switching tasks involves the physical setup of a task (opening a document on the computer, setting a brushes for painting, etc), whereas the “cognitive” cost is due to switching out the working memory maintained while working on a task (e.g. what sentence to write next, in which region to paint). The human task-switching literature has focused primarily on quantifying the cognitive cost of task switching. However, this cost may in fact be irrelevant if the procedural cost is high enough. Interestingly, for operating systems, it may also be negligible for simple tasks where both tasks fit in cache. It’s possible that there are tasks simple enough that they incur almost no cognitive cost for humans as well.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org1b51ba4">
<h3 id="time-to-completion:-often-unknown"><span class="section-number-3">1.2</span> Time to completion: often unknown</h3>
<div class="outline-text-3" id="text-time-to-completion:-often-unknown">
<p>
Something that I find really interesting in the OS literature, which is completely glossed over in <i>Algorithms to Live By</i>, is that most of modern scheduling algorithms don’t make any assumptions about the length of each task when scheduling them. People are notoriously bad at estimating tasks<sup><a class="footref" href="#fn.4" id="fnr.4">4</a></sup>, so having a system which can process multiple tasks of arbitrary lengths robustly seems rather interesting. In both of the modern schedulers described below, the scheduler is designed to handle a mix of long and short running tasks with minimal sacrifices on the run time of either.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgd76bb96">
<h3 id="turnaround-time-vs-response-time:-choose-one"><span class="section-number-3">1.3</span> Turnaround time vs response time: choose one</h3>
<div class="outline-text-3" id="text-turnaround-time-vs-response-time:-choose-one">
<p>
A natural metric to optimize for completing tasks is the “turnaround time”, defined as the time from task arrival to task completion. However, engineers of interactive systems quickly realized that considering only turnaround time leads to laggy and unresponsive interfaces. This is because, optimizing for turnaround time, the system would just run one task at time, for a long time. Thus, from the perspective of the user, their task would usually freeze up
until all the other shorter tasks completed.
</p>
<p>
The solution is to measure and optimize the response time, the time from the task arrival to the first task run. I find this interesting, as in our modern social networks we are often incentivized to minimize response time, rather than turnaround time, which naturally leads to us performing tasks in <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">round-robin</a> style.  Rather than holding turnaround time as the best metric and completely discounting round-robin scheduling, as so many “productivity gurus” often do, it can be helpful to think about the balance between response time and turnaround time, and what you might be trading off when picking one to optimize.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-org6254490">
<h3 id="Input/output:-blocks-tasks"><span class="section-number-3">1.4</span> Input/output: blocks tasks</h3>
<div class="outline-text-3" id="text-Input/output:-blocks-tasks">
<p>
Another consideration when scheduling tasks is the waiting time for input/output. For instance, when the CPU is reading from or writing to a hard drive, it must wait for the hard drive to respond before continuing to execute the task, as hard drives are orders of magnitude slower than CPUs. But it could be executing other tasks during this time!
</p>
<p>
A similar principle applies for human tasks. When running the laundry, for instance, it’s more efficient to not wait for the washer to finish before starting another task. Similarly, when waiting for a reply to a message or waiting for water to boil, it’s more efficient be doing something else. You can think of delegating tasks to people or machines in this way as well. Still, how can you schedule tasks most efficiently while keeping this in mind? The modern algorithms below handle these issues naturally.
</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org282dce6">
<h2 id="Modern-operating-system-schedulers"><span class="section-number-2">2</span> Modern operating system schedulers</h2>
<div class="outline-text-2" id="text-Modern-operating-system-schedulers">
</div>
<div class="outline-3" id="outline-container-orgfaa640b">
<h3 id="Multi-level-feedback-queue"><span class="section-number-3">2.1</span> Multi-level feedback queue</h3>
<div class="outline-text-3" id="text-Multi-level-feedback-queue">
<p>
The multi-level feedback queue strikes a balance between turnaround time (how long it takes you to complete a task) and response time (how long before you start on the task), while making few assumptions about the run time of the tasks. How does it do this?
</p>
<p>
Essentially, it schedules tasks according to the <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf">following rules</a><sup><a class="footref" href="#fn.5" id="fnr.5">5</a></sup>:
</p>
<ol class="org-ol">
<li>If Priority(A) &gt; Priority(B), A runs and B doesn’t.</li>
<li>If Priority(A) = Priority(B), A &amp; B run in round-robin fashion using the time slice (quantum length) of the given queue.</li>
<li>When a job enters the system, it is placed at the highest priority (the topmost queue).</li>
<li>Once a job uses up its time allotment at a given level, its priority is reduced (i.e., it moves down one queue).</li>
<li>After some time period S, move all the jobs in the system to the topmost queue</li>
</ol>
<p>
This system gives a higher priority to incoming jobs. They’ll run first, maximizing response time. If they’re short, they’ll also finish quickly. However, if they turn out to be longer, they’ll get moved into a lower queue, which will only run after every other job. In order to continue running the longer jobs if there are too many interactive jobs, all the priorities are reset periodically.
In some variants, the lower priority queues have longer time slices, as the non-interactive jobs are often CPU bound and this reduces <a href="#context-switching:-cognitive-vs-procedural">context switching costs</a>.
</p>
<p>
Pros:
</p>
<ul class="org-ul">
<li>automatic adjustment of priorities based on observed runtime</li>
<li>good tradeoff between response time and turnaround time</li>
</ul>
<p>
Cons:
</p>
<ul class="org-ul">
<li>no way to specify which jobs have higher priority permanently</li>
<li>priority reset (rule 5) feels like it would be tricky to implement for human scheduling</li>
<li>need a system to manage task priorities</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-orgea3ec83">
<h3 id="Fair-share-scheduler"><span class="section-number-3">2.2</span> Fair-share scheduler</h3>
<div class="outline-text-3" id="text-Fair-share-scheduler">
<p>
Rather optimizing turnaround time and response time, you could try to spend the same amount of time for each task. This is the idea behind the “<a href="https://en.wikipedia.org/wiki/Fair-share_scheduling">fair-share scheduler</a>”, used (with some variations) in the <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Linux kernel</a>. There are two main ways that people have implemented a fair-share system. In the first, you would allocate “tickets” to each task based on its priority, and then draw a ticket at random for each slot of time. In the second (and the way Linux does it), keep track of how much time you’ve spent on each task (a “virtual runtime”) and run the task you’ve spent the least time on at each slot.<sup><a class="footref" href="#fn.6" id="fnr.6">6</a></sup>
</p>
<p>
Pros:
</p>
<ul class="org-ul">
<li>ticket system is simple to implement</li>
<li>easy to tune the priority of tasks</li>
</ul>
<p>
Cons:
</p>
<ul class="org-ul">
<li>tasks which mostly wait on input do not get their fair share</li>
<li>must tune priorities manually</li>
<li>the second approach (based on “virtual runtime”) seems harder to implement in practice</li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgb5f8c34">
<h2 id="Scheduling-for-humans"><span class="section-number-2">3</span> Scheduling for humans</h2>
<div class="outline-text-2" id="text-Scheduling-for-humans">
<p>
Between the two modern scheduling systems, the fair-share scheduling system seems like the easiest to adopt. Indeed, the author and artist <a href="https://www.vivianeschwarz.co.uk/">Viviane Schwarz</a> <a href="https://usesthis.com/interviews/viviane.schwarz/">uses</a> a fair-share scheduling system for her tasks, to great effect:
</p>
<blockquote>
<p>
One of my most important work tools is a bingo wheel which I throw wooden balls in labelled with the projects I need to work on. […] I spin out a project, set a timer and work on it for half an hour or an hour to take it forward, then I spin again until it’s time to stop working. It sounds quite ridiculous but it beats every other system I’ve ever tried for productivity; you just have to make sure the right balls are in the cage, throw in more if a deadline is approaching or take some out if something gets less urgent.
</p>
</blockquote>
<p>
I’m intrigued by the automatic priority management of the multilevel feedback queue as well, although using it would require logging time spent on each task. I haven’t found anyone doing this exactly, but <a href="https://webcache.googleusercontent.com/search?q=cache:yzOGbMOldToJ:https://applyhitech.com/2018/04/27/does-your-to-do-list-behave-like-a-queue-a-stack-or-a-priority-queue/+&amp;cd=16&amp;hl=en&amp;ct=clnk&amp;gl=us&amp;client=ubuntu">there is</a> <a href="https://briantomasik.com/how-i-use-todo-lists/#Treating_todo_lists_as_priority_queues">some</a> <a href="https://softwarerecs.stackexchange.com/questions/66547/todo-list-application-that-uses-a-priority-queue">precedent</a> in thinking of todo lists as priority queues.
</p>
<p>
Either way, I couldn’t find anything to manage todo lists in this way. It would be a useful application if someone does develop it!
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<div class="footdef"><sup><a class="footnum" href="#fnr.1" id="fn.1">1</a></sup> <div class="footpara"><p class="footpara">
Based on the book, I also made a couple of small changes to my life, notably buying a stand for my clothes and making more heavy use of the “recently modified” heuristic when sorting things (or at least, feeling more comfortable with it as reasonably optimal). Still, the scheduling parallel is what interested me the most in the end.
</p></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.2" id="fn.2">2</a></sup> <div class="footpara"><p class="footpara">
The book covers scheduling tradeoffs at a pretty high level, focusing primarily on the <a href="https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling">earliest deadline first (EDF)</a> and <a href="https://en.wikipedia.org/wiki/Shortest_job_next">shortest job next (SJN)</a> algorithms, and has brief discussions on priority inversion and context switching. The book’s focus is understandable given the its audience and space constraints, but the recommendations for practical time management feel somewhat shallow (e.g. beware of context switching, check prerequisites for tasks).
</p></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.3" id="fn.3">3</a></sup> <div class="footpara"><p class="footpara">In the OS literature, “procedural” and “cognitive” costs are generally referred to as “direct” and “indirect” costs.</p></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.4" id="fn.4">4</a></sup> <div class="footpara"><p class="footpara">
For instance, the majority of students underestimated how long it would take to finish a paper by about 50% when optimistic, and even by 12% when asked to make a pessimistic estimate.  (Buehler, Griffin, Ross, 1994)
</p></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.5" id="fn.5">5</a></sup> <div class="footpara"><p class="footpara">
Lifted from <i>Operating Systems: Three Easy Pieces</i> by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau.
</p></div></div>
<div class="footdef"><sup><a class="footnum" href="#fnr.6" id="fn.6">6</a></sup> <div class="footpara"><p class="footpara">
To continue spending time on long running tasks, you need <a href="https://stackoverflow.com/questions/34999892/completely-fair-scheduler-cfs-vruntime-of-long-running-processes">to pretend</a> that new tasks have been running for the minimum time you’ve spent on any current task.
</p></div></div>
</div>
</div></div>
</body>
</html>
